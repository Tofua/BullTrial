<!DOCTYPE html>
<html>
<head>
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <script type="text/javascript">window.$crisp=[];window.CRISP_WEBSITE_ID="fbcb448a-beca-4eb3-9ff0-aa11729254b2";(function(){d=document;s=d.createElement("script");s.src="https://client.crisp.chat/l.js";s.async=1;d.getElementsByTagName("head")[0].appendChild(s);})();</script>
  <meta charset="UTF-8">
  <title>BullWhip App</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/powerbi-client/2.19.1/powerbi.min.js"></script>
  <style>
    /* -----------------------------------------------------------
       1) Base Reset + Font
    ----------------------------------------------------------- */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      margin: 0;
      padding: 0;
      height: 100vh;
      overflow: hidden;
      position: relative;
      background-color: #f5f5f5;
    }

    /* -----------------------------------------------------------
       2) Canvas Background for Floating Circles
    ----------------------------------------------------------- */
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0; /* behind everything else */
    }

    /* -----------------------------------------------------------
       3) LOGIN SECTION
         - We wrap the login card in its own container (#loginSection).
    ----------------------------------------------------------- */
    #loginSection {
      width: 100%;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
      z-index: 1; /* in front of the canvas */
    }
    .login-card {
      width: 360px;
      background: white;
      padding: 40px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
      position: relative;
    }
    /* Small brand accent bar at the top of the login card */
    .brand-accent {
      height: 4px;
      background: #F05123; /* from login.html brand color */
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      border-radius: 8px 8px 0 0;
    }
    .login-header {
      margin-bottom: 32px;
      text-align: center;
      margin-top: 8px; /* so we see the accent bar above it */
    }
    .login-header h2 {
      color: #333;
      font-weight: 500;
      font-size: 22px;
      margin-bottom: 6px;
    }
    .form-group {
      margin-bottom: 20px;
    }
    .form-group label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      color: #555;
      font-size: 14px;
    }
    .form-group input {
      width: 100%;
      padding: 12px;
      background: #fff;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      font-size: 15px;
      transition: border-color 0.2s, box-shadow 0.2s;
    }
    .form-group input:focus {
      outline: none;
      border-color: #F05123;
      box-shadow: 0 0 0 3px rgba(240, 81, 35, 0.1);
    }
    .login-button {
      width: 100%;
      padding: 12px;
      background: #F05123;
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 15px;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s, transform 0.2s;
      margin-top: 8px;
    }
    .login-button:hover {
      background: #d84418;
      transform: translateY(-1px);
    }
    .login-button:active {
      transform: translateY(1px);
    }
    .error-message {
      background-color: #fff8f8;
      color: #e55353;
      padding: 12px;
      border-radius: 6px;
      font-size: 14px;
      margin-top: 16px;
      display: none;
      text-align: center;
      border: 1px solid #fcd8d8;
    }

    /* -----------------------------------------------------------
       4) DASHBOARD SECTION (Initially Hidden)
    ----------------------------------------------------------- */
    #dashboardSection {
      display: none; /* hidden until user logs in */
      width: 100%;
      height: 100vh;
      position: relative;
      z-index: 1;
    }
    #reportContainer {
      width: 100%;
      height: 100vh;
      position: relative;
    }

    /* Floating controls container - from alittlebitofdislittlebitofdat19.html */
    #floatingControls {
      position: fixed;
      top: 15px;
      right: 120px;
      z-index: 2147483647;
      display: flex;
      gap: 10px;
      background-color: rgba(255, 255, 255, 0.95);
      padding: 10px;
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      cursor: move; /* Draggable */
      user-select: none; 
    }
    .control-button {
      width: 36px;
      height: 36px;
      border-radius: 4px;
      border: 1px solid #ddd;
      background-color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .control-button:hover {
      background-color: #f0f0f0;
    }
    .control-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* The small "Loading..." indicator in the corner */
    #loadingIndicator {
      position: fixed;
      top: 15px;
      left: 15px;
      padding: 8px 12px;
      background-color: rgba(255, 243, 205, 0.9);
      color: #856404;
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      z-index: 2147483647; 
      display: none;
      max-width: 250px;
    }
    /* Big overlay for normal loading events */
    #loadingOverlay {
      position: fixed; 
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(255, 255, 255, 0.7);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 2147483647; 
      display: none;
    }
    /* Non-blocking spinner for refresh */
    #refreshSpinner {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 2147483648; 
      pointer-events: none; 
      display: none;
    }
    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid #f3f3f3; 
      border-top: 4px solid #0078d4; 
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0%   { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .loading-text {
      margin-top: 10px;
      font-size: 14px;
      color: #333;
      background-color: rgba(255, 255, 255, 0.8);
      padding: 5px 10px;
      border-radius: 4px;
    }

    /* Error message style reused from snippet */
    .error {
      position: fixed;
      top: 15px;
      left: 15px;
      color: #721c24;
      background-color: rgba(248, 215, 218, 0.9);
      border: 1px solid rgba(245, 198, 203, 0.9);
      padding: 10px;
      border-radius: 4px;
      z-index: 2147483647;
      max-width: 80%;
      display: none;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    }

    /* Fullscreen message prompt */
    #fullscreenPrompt {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 60px 30px 30px 30px;
      background-color: rgba(255, 255, 255, 0.95);
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      text-align: center;
      z-index: 2147483647;
      width: 300px;
      display: none; /* hidden by default */
      flex-direction: column;
      align-items: center;
      gap: 15px;
    }
    #fullscreenPrompt p {
      margin: 0;
      font-size: 16px;
    }
    #fullscreenPrompt button {
      padding: 10px 20px;
      background-color: #0078d4;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
    }
    #fullscreenPrompt button:hover {
      background-color: #0069b9;
    }
    #closeFullscreenPrompt {
      position: absolute;
      top: 15px;
      right: 15px;
      width: 24px;
      height: 24px;
      background-color: transparent;
      border: none;
      font-size: 18px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #666;
    }
    #closeFullscreenPrompt:hover {
      color: #333;
    }
    .fullscreen-icon {
      transition: all 0.3s ease;
    }
  </style>
</head>

<body>
  <!-- The floating circles canvas -->
  <canvas id="canvas"></canvas>

<!-- LOGIN SECTION -->
<div id="loginSection">
  <div class="login-card">
    <div class="brand-accent"></div>
    <div class="login-header">
      <!-- Replace this src with the correct logo path or URL -->
      <img src="images/Bull_Run_Logo_Png.png" alt="Company Logo" style="height: 40px; margin-bottom: 16px;">
      <h2>Dashboard Login</h2>
    </div>
    
    <div class="form-group">
      <label for="username">Username</label>
      <input type="text" id="username" placeholder="Enter username">
    </div>
    
    <div class="form-group">
      <label for="password">Password</label>
      <input type="password" id="password" placeholder="Enter password">
    </div>
    
    <button type="button" class="login-button" id="loginBtn">Login</button>

    <div class="error-message" id="loginErrorMsg">
      Invalid username or password. Please try again.
    </div>
  </div>
</div>


  <!-- DASHBOARD SECTION (hidden until login) -->
  <div id="dashboardSection">
    <div id="errorMessage" class="error"></div>
    <div id="loadingIndicator">Loading...</div>
    <div id="loadingOverlay">
      <div class="spinner"></div>
      <div class="loading-text">Loading...</div>
    </div>
    <div id="refreshSpinner">
      <div class="spinner"></div>
    </div>
      <!-- Add the logout button here -->
  <button id="logoutBtn" style="position: fixed; top: 15px; right: 15px; z-index: 2147483647; padding: 8px 15px; background-color: #F05123; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">Logout</button>
  
  <div id="reportContainer"></div>
  <div id="fullscreenPrompt">
    <button id="closeFullscreenPrompt" title="Close">✕</button>
    <p>Click the button below to enter fullscreen mode</p>
    <button id="promptFullscreenBtn">Enter Fullscreen</button>
  </div>
</div>
    <div id="reportContainer"></div>
    <div id="fullscreenPrompt">
      <button id="closeFullscreenPrompt" title="Close">✕</button>
      <p>Click the button below to enter fullscreen mode</p>
      <button id="promptFullscreenBtn">Enter Fullscreen</button>
    </div>
  </div>
  <script>
    // Get references to your logout button and relevant sections
    const logoutBtn = document.getElementById('logoutBtn');
  
    logoutBtn.addEventListener('click', () => {
      // 1) Clear any saved filter values or user info
      filterValues = {
        orgIN: "",
        userIN: ""
      };
  
      // 2) Hide the dashboard
      dashboardSection.style.display = 'none';
  
      // 3) Show the login section again
      loginSection.style.display = 'flex';
  
      // 4) Reset or remove the embedded Power BI report
      //    so the next login uses a fresh embed.
      const reportContainer = document.getElementById('reportContainer');
      powerbi.reset(reportContainer);
  
      // 5) (Optional) remove or hide any floating controls so
      //    they don’t stay on screen.
      const floatingControls = document.getElementById('floatingControls');
      if (floatingControls) {
        floatingControls.remove();
      }
  
      // 6) (Optional) clear username / password fields
      usernameInput.value = '';
      passwordInput.value = '';
    });
  </script>
  

  <script>
    /* ===========================================================
       PART A: CANVAS BACKGROUND & FLOATING CIRCLES (from login.html)
    =========================================================== */
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    function setCanvasSize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', setCanvasSize);
    setCanvasSize();

    let mouse = {
      x: undefined,
      y: undefined,
      radius: 120
    };
    window.addEventListener('mousemove', function(event) {
      mouse.x = event.x;
      mouse.y = event.y;
    });

    class Circle {
      constructor(x, y, radius, color) {
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.color = color;
        this.baseRadius = radius;

        this.speedX = (Math.random() - 0.5) * 0.3;
        this.speedY = (Math.random() - 0.5) * 0.3;

        this.speedVariation = Math.random() * 0.05;
        this.speedAngle = Math.random() * Math.PI * 2;

        this.density = (Math.random() * 15) + 5;
        this.opacity = 0.5 + Math.random() * 0.3;
      }

      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.opacity;
        ctx.fill();
        ctx.globalAlpha = 1;
      }

      update() {
        // Slight wave movement
        this.speedX += Math.sin(this.speedAngle) * this.speedVariation;
        this.speedY += Math.cos(this.speedAngle) * this.speedVariation;
        this.speedAngle += 0.005;

        // Limit speed
        if (this.speedX > 0.4) this.speedX = 0.4;
        if (this.speedX < -0.4) this.speedX = -0.4;
        if (this.speedY > 0.4) this.speedY = 0.4;
        if (this.speedY < -0.4) this.speedY = -0.4;

        this.x += this.speedX;
        this.y += this.speedY;

        // Boundary bounce
        if (this.x < this.radius) {
          this.x = this.radius;
          this.speedX = -this.speedX;
        }
        if (this.x > canvas.width - this.radius) {
          this.x = canvas.width - this.radius;
          this.speedX = -this.speedX;
        }
        if (this.y < this.radius) {
          this.y = this.radius;
          this.speedY = -this.speedY;
        }
        if (this.y > canvas.height - this.radius) {
          this.y = canvas.height - this.radius;
          this.speedY = -this.speedY;
        }

        // Mouse interaction
        if (mouse.x !== undefined && mouse.y !== undefined) {
          const dx = mouse.x - this.x;
          const dy = mouse.y - this.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < mouse.radius + this.radius) {
            const angle = Math.atan2(dy, dx);
            const force = (mouse.radius - distance) / mouse.radius;
            const moveX = Math.cos(angle) * force * this.density;
            const moveY = Math.sin(angle) * force * this.density;

            this.x -= moveX * 0.7;
            this.y -= moveY * 0.7;
          }
        }
        this.draw();
      }
    }

    let circles = [];
    function initCircles() {
      circles = [];
      const screenArea = canvas.width * canvas.height;
      const circleCount = Math.max(20, Math.min(80, Math.floor(screenArea / 15000)));

      const colors = [
        'rgba(240, 81, 35, 0.07)',   // Very subtle brand color
        'rgba(240, 81, 35, 0.05)',   // Even more subtle brand color
        'rgba(245, 245, 245, 0.5)',  // Light gray
        'rgba(250, 250, 250, 0.5)',  // Off-white
        'rgba(240, 240, 240, 0.5)'   // Another light gray
      ];

      for (let i = 0; i < circleCount; i++) {
        const radius = Math.random() * 20 + 5;
        const x = Math.random() * (canvas.width - radius * 2) + radius;
        const y = Math.random() * (canvas.height - radius * 2) + radius;
        const color = colors[Math.floor(Math.random() * colors.length)];
        circles.push(new Circle(x, y, radius, color));
      }
    }
    function animate() {
      requestAnimationFrame(animate);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      circles.forEach(circle => {
        circle.update();
      });
    }
    initCircles();
    animate();

    window.addEventListener('resize', function() {
      setCanvasSize();
      initCircles();
    });
    window.addEventListener('mouseout', function() {
      mouse.x = undefined;
      mouse.y = undefined;
    });

    /* ===========================================================
   PART B: LOGIN & DASHBOARD LOGIC (from alittlebitofdislittlebitofdat19.html)
=========================================================== */
const loginSection = document.getElementById('loginSection');
const dashboardSection = document.getElementById('dashboardSection');
const loginBtn = document.getElementById('loginBtn');
const loginErrorMsg = document.getElementById('loginErrorMsg');
const usernameInput = document.getElementById('username');
const passwordInput = document.getElementById('password');

// Define user credentials with their corresponding filter values
const userCredentials = [
  { username: "Admin", password: "Password", userIN: "S H", orgIN: "BW" },
  { username: "MikeP", password: "BullMike", userIN: "MP", orgIN: "JW" },
  { username: "NeilG", password: "BullNeil", userIN: "NG", orgIN: "JW" }
];

// Default to empty filter values (will be set after login)
let filterValues = {
  orgIN: "",
  userIN: ""
};

function attemptLogin() {
  const username = usernameInput.value.trim();
  const password = passwordInput.value;

  // Find matching credentials
  const user = userCredentials.find(
    u => u.username.toLowerCase() === username.toLowerCase() && u.password === password
  );

  if (user) {
    // Set filter values based on user credentials
    filterValues.orgIN = user.orgIN;
    filterValues.userIN = user.userIN;
    
    // Hide login, show dashboard
    loginSection.style.display = 'none';
    dashboardSection.style.display = 'block';
    loginErrorMsg.style.display = 'none';
    
    // Now initialize the Power BI embed
    initializeDashboard();
  } else {
    // Show error
    loginErrorMsg.style.display = 'block';
    passwordInput.value = '';
    setTimeout(() => {
      loginErrorMsg.style.display = 'none';
    }, 3000);
  }
}

loginBtn.addEventListener('click', attemptLogin);
passwordInput.addEventListener('keypress', (e) => {
  if (e.key === 'Enter') {
    attemptLogin();
  }
});

/* -----------------------------------------------------------
   Initialize the actual Power BI dashboard after login
----------------------------------------------------------- */
function initializeDashboard() {
  // Global variables for token refresh and report tracking
  let tokenRefreshInterval;
  let currentAccessToken;
  let report;
  let currentPage;
  let pages = [];

  // Function to refresh the Power BI token automatically
  function startTokenRefreshTimer() {
    // Clear any existing interval first
    clearInterval(tokenRefreshInterval);
    
    // Set to refresh every 40 minutes (40 * 60 * 1000 milliseconds)
    const refreshIntervalMs = 40 * 60 * 1000;
    
    console.log(`Token refresh timer started. Will refresh every ${refreshIntervalMs/60000} minutes.`);
    
    tokenRefreshInterval = setInterval(async () => {
      console.log("Token refresh timer triggered. Fetching new token...");
      try {
        const response = await fetch("https://powerbitokenapp.azurewebsites.net/api/GetEmbedToken?code=XzC3pncLfW__oe3-UMCbQikTv5-7OrElhjknmOHVMmgDAzFuOUDPng==");
        const data = await response.json();
        currentAccessToken = data.token;
        
        console.log("New token obtained. Updating report...");
        
        // Update the token in the active report
        if (report) {
          await report.setAccessToken(currentAccessToken);
          console.log("Report access token updated successfully");
        }
      } catch (error) {
        console.error("Error refreshing token:", error);
        showError("Failed to refresh authentication token. You may need to reload the page.");
      }
    }, refreshIntervalMs);
  }

  // Function to stop the token refresh timer when needed
  function stopTokenRefreshTimer() {
    clearInterval(tokenRefreshInterval);
    console.log("Token refresh timer stopped");
  }

  // ***** NEW: Token Expiration Overlay Functions *****
  // This function creates a frosted overlay with a "Refresh Access" button
  function showTokenExpiredOverlay() {
    // Create overlay element
    const overlay = document.createElement('div');
    overlay.id = 'tokenExpiredOverlay';
    overlay.style.position = 'absolute';
    overlay.style.top = '0';
    overlay.style.left = '0';
    overlay.style.width = '100%';
    overlay.style.height = '100%';
    overlay.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
    overlay.style.backdropFilter = 'blur(5px)';
    overlay.style.display = 'flex';
    overlay.style.flexDirection = 'column';
    overlay.style.justifyContent = 'center';
    overlay.style.alignItems = 'center';
    overlay.style.zIndex = '1000'; // Ensure it’s on top
    overlay.innerHTML = `
      <p style="font-size: 1.2em; margin-bottom: 20px;">Access token expired.</p>
      <button id="refreshAccessBtn" style="padding: 10px 20px; font-size: 1em;">Refresh Access</button>
    `;

    // Append overlay to the report container
    const reportContainer = document.getElementById('reportContainer');
    reportContainer.style.position = 'relative'; // Ensure proper positioning
    reportContainer.appendChild(overlay);

    // Add click event for refreshing the token manually
    document.getElementById('refreshAccessBtn').addEventListener('click', async () => {
      await refreshAccessToken();
      overlay.remove();
    });
  }

  // This function refreshes the token manually when the user clicks "Refresh Access"
  async function refreshAccessToken() {
    try {
      console.log("Manual token refresh triggered.");
      const response = await fetch("https://powerbitokenapp.azurewebsites.net/api/GetEmbedToken?code=XzC3pncLfW__oe3-UMCbQikTv5-7OrElhjknmOHVMmgDAzFuOUDPng==");
      const data = await response.json();
      currentAccessToken = data.token;
      if (report) {
        await report.setAccessToken(currentAccessToken);
        console.log("Token refreshed and updated on the report.");
      }
    } catch (error) {
      console.error("Error refreshing token manually:", error);
      showError("Failed to refresh token. Please try again.");
    }
  }
  // ***** End NEW code *****

  // Create floating controls
  const floatingControls = document.createElement('div');
  floatingControls.id = 'floatingControls';
  floatingControls.innerHTML = `
    <button id="fullscreenBtn" class="control-button" title="Enter Fullscreen">
      <span class="button-label fullscreen-icon">
        <svg width="16" height="16" viewBox="0 0 24 24"
          fill="none" stroke="currentColor" stroke-width="2"
          stroke-linecap="round" stroke-linejoin="round">
          <polyline points="15 3 21 3 21 9"></polyline>
          <polyline points="9 21 3 21 3 15"></polyline>
          <line x1="21" y1="3" x2="14" y2="10"></line>
          <line x1="3" y1="21" x2="10" y2="14"></line>
        </svg>
      </span>
    </button>
    <button id="pageIconBtn" class="control-button" title="Change Page">
      <span class="button-label page-icon">
        <svg width="16" height="16" viewBox="0 0 24 24"
          fill="none" stroke="currentColor" stroke-width="2"
          stroke-linecap="round" stroke-linejoin="round">
          <circle cx="11" cy="11" r="8"></circle>
          <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
        </svg>
      </span>
    </button>
    <button id="refreshVisualsBtn" class="control-button" title="Refresh Visuals">
      <span class="button-label">↻</span>
    </button>
  `;
  document.body.appendChild(floatingControls);
  makeDraggable(floatingControls);

  function makeDraggable(element) {
    let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
    element.onmousedown = dragMouseDown;
    function dragMouseDown(e) {
      e.preventDefault();
      pos3 = e.clientX;
      pos4 = e.clientY;
      document.onmouseup = closeDragElement;
      document.onmousemove = elementDrag;
    }
    function elementDrag(e) {
      e.preventDefault();
      pos1 = pos3 - e.clientX;
      pos2 = pos4 - e.clientY;
      pos3 = e.clientX;
      pos4 = e.clientY;
      const newTop = element.offsetTop - pos2;
      const newLeft = element.offsetLeft - pos1;
      element.style.top = newTop + "px";
      element.style.left = newLeft + "px";
      element.style.right = "auto";
    }
    function closeDragElement() {
      document.onmouseup = null;
      document.onmousemove = null;
    }
  }

  function showLoading(message, mode = "normal") {
    const loadingIndicator = document.getElementById('loadingIndicator');
    const loadingOverlay = document.getElementById('loadingOverlay');
    const refreshSpinner = document.getElementById('refreshSpinner');
    const overlayText = loadingOverlay.querySelector('.loading-text');

    const finalMessage = message || "Loading...";
    loadingIndicator.textContent = finalMessage;
    loadingIndicator.style.display = 'block';

    if (mode === "refresh") {
      refreshSpinner.style.display = 'block';
      loadingOverlay.style.display = 'none';
    } else {
      overlayText.textContent = finalMessage;
      loadingOverlay.style.display = 'flex';
      refreshSpinner.style.display = 'none';
    }
  }

  function hideLoading() {
    document.getElementById('loadingIndicator').style.display = 'none';
    document.getElementById('loadingOverlay').style.display = 'none';
    document.getElementById('refreshSpinner').style.display = 'none';
  }

  function showError(message) {
    const errorElement = document.getElementById('errorMessage');
    errorElement.style.display = 'block';
    errorElement.textContent = message;
    console.error(message);
    setTimeout(() => {
      errorElement.style.display = 'none';
    }, 7000);
  }

  function showFullscreenPrompt() {
    document.getElementById('fullscreenPrompt').style.display = 'flex';
  }

  function hideFullscreenPrompt() {
    document.getElementById('fullscreenPrompt').style.display = 'none';
  }

  document.getElementById('closeFullscreenPrompt').addEventListener('click', hideFullscreenPrompt);

  async function enterFullscreen() {
    if (!document.fullscreenElement) {
      if (document.documentElement.requestFullscreen) {
        await document.documentElement.requestFullscreen();
        const fullscreenIcon = document.querySelector('.fullscreen-icon');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        if (fullscreenIcon) {
          fullscreenIcon.textContent = '⤓';
          fullscreenBtn.title = "Exit Fullscreen";
        }
      }
    }
  }

  async function exitFullscreen() {
    if (document.exitFullscreen) {
      await document.exitFullscreen();
      const fullscreenIcon = document.querySelector('.fullscreen-icon');
      const fullscreenBtn = document.getElementById('fullscreenBtn');
      if (fullscreenIcon) {
        // restore the original SVG
        fullscreenIcon.innerHTML = `
          <svg width="16" height="16" viewBox="0 0 24 24"
            fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round">
            <polyline points="15 3 21 3 21 9"></polyline>
            <polyline points="9 21 3 21 3 15"></polyline>
            <line x1="21" y1="3" x2="14" y2="10"></line>
            <line x1="3" y1="21" x2="10" y2="14"></line>
          </svg>`;
        fullscreenBtn.title = "Enter Fullscreen";
      }
    }
  }

  document.getElementById('promptFullscreenBtn').addEventListener('click', async () => {
    hideFullscreenPrompt();
    await enterFullscreen();
  });

  document.addEventListener('keydown', function (event) {
    if (event.key === 'F11') {
      event.preventDefault();
      const fullscreenBtn = document.getElementById('fullscreenBtn');
      if (fullscreenBtn) fullscreenBtn.click();
    }
  });

  document.addEventListener('fullscreenchange', function () {
    if (!document.fullscreenElement) {
      const fullscreenIcon = document.querySelector('.fullscreen-icon');
      const fullscreenBtn = document.getElementById('fullscreenBtn');
      if (fullscreenIcon) {
        fullscreenIcon.innerHTML = `
          <svg width="16" height="16" viewBox="0 0 24 24"
            fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round">
            <polyline points="15 3 21 3 21 9"></polyline>
            <polyline points="9 21 3 21 3 15"></polyline>
            <line x1="21" y1="3" x2="14" y2="10"></line>
            <line x1="3" y1="21" x2="10" y2="14"></line>
          </svg>`;
        fullscreenBtn.title = "Enter Fullscreen";
      }
    }
  });

  const pageIconBtn = document.getElementById('pageIconBtn');
  const fullscreenBtn = document.getElementById('fullscreenBtn');
  if (fullscreenBtn) {
    fullscreenBtn.addEventListener('click', async () => {
      if (document.fullscreenElement) {
        await exitFullscreen();
      } else {
        await enterFullscreen();
      }
    });
  }

  fetch("https://powerbitokenapp.azurewebsites.net/api/GetEmbedToken?code=XzC3pncLfW__oe3-UMCbQikTv5-7OrElhjknmOHVMmgDAzFuOUDPng==")
    .then(response => response.json())
    .then(data => {
      currentAccessToken = data.token;
      const reportId = "782913b3-f792-4f84-bc87-d46092f64932";
      const models = window['powerbi-client'].models;

      // filterValues is now set by the login process
      console.log(`Using filters for: orgIN=${filterValues.orgIN}, userIN=${filterValues.userIN}`);
      
      // Define filters for the entire report (applied to all pages)
      const reportFilters = [
        {
          $schema: "http://powerbi.com/product/schema#basic",
          target: { table: "Users", column: "OrganisationInitials" },
          operator: "In",
          values: [filterValues.orgIN]
        },
        {
          $schema: "http://powerbi.com/product/schema#basic",
          target: { table: "Users", column: "Name" },
          operator: "In",
          values: [filterValues.userIN]
        }
      ];
      
      // Define filters for page 1 (Prospect)
      const page1Filters = [
        {
          $schema: "http://powerbi.com/product/schema#basic",
          target: { table: "ListTableClone", column: "OrganisationIN" },
          operator: "In",
          values: [filterValues.orgIN]
        },
        {
          $schema: "http://powerbi.com/product/schema#basic",
          target: { table: "ListTableClone", column: "initial" },
          operator: "In",
          values: [filterValues.userIN]
        },
        {
          $schema: "http://powerbi.com/product/schema#basic",
          target: { table: "Contactstest", column: "OrganisationIN" },
          operator: "In",
          values: [filterValues.orgIN]
        }
      ];
      
      // Define filters for page 2 (Pinpoint)
      const page2Filters = [
        {
          $schema: "http://powerbi.com/product/schema#basic",
          target: { table: "IntermediaryCompanyNumbers", column: "OrganisationIN" },
          operator: "In",
          values: [filterValues.orgIN]
        },
        {
          $schema: "http://powerbi.com/product/schema#basic",
          target: { table: "intermediarylist", column: "OrganisationIN" },
          operator: "In",
          values: [filterValues.orgIN]
        },
        {
          $schema: "http://powerbi.com/product/schema#basic",
          target: { table: "intermediarylist", column: "Initials" },
          operator: "In",
          values: [filterValues.userIN]
        },
        {
          $schema: "http://powerbi.com/product/schema#basic",
          target: { table: "ListTable", column: "OrganisationIN" },
          operator: "In",
          values: [filterValues.orgIN]
        },
        {
          $schema: "http://powerbi.com/product/schema#basic",
          target: { table: "ListTable", column: "initial" },
          operator: "In",
          values: [filterValues.userIN]
        },
        {
          $schema: "http://powerbi.com/product/schema#basic",
          target: { table: "LLMTable", column: "OrganisationIN" },
          operator: "In",
          values: [filterValues.orgIN]
        },
        {
          $schema: "http://powerbi.com/product/schema#basic",
          target: { table: "LLMTable", column: "Initials" },
          operator: "In",
          values: [filterValues.userIN]
        },
        {
          $schema: "http://powerbi.com/product/schema#basic",
          target: { table: "company_profiles", column: "OrganisationIN" },
          operator: "In",
          values: [filterValues.orgIN]
        }
      ];

      const embedConfiguration = {
        type: "report",
        id: reportId,
        embedUrl: `https://app.powerbi.com/reportEmbed?reportId=${reportId}`,
        tokenType: models.TokenType.Aad,
        accessToken: currentAccessToken,
        permissions: models.Permissions.Read,
        settings: {
          panes: {
            filters: { visible: false },
            pageNavigation: { visible: false }
          },
          bars: {
            statusBar: { visible: true }
          }
        }
      };

      // Apply specific filters to a specific page by name
      async function applyFiltersToPage(pageName, pageFilters) {
        try {
          // Get all pages
          const allPages = await report.getPages();
          console.log("Available pages:", allPages.map(p => ({name: p.name, displayName: p.displayName})));
          
          // Find the target page by name or display name
          const targetPage = allPages.find(p => 
            p.name === pageName || 
            p.displayName === pageName ||
            p.name.includes(pageName) || 
            p.displayName.includes(pageName)
          );
          
          if (!targetPage) {
            console.error(`Page "${pageName}" not found. Available pages: ${allPages.map(p => p.name).join(", ")}`);
            return false;
          }
          
          console.log(`Applying filters to page: ${targetPage.displayName} (${targetPage.name})...`);
          await targetPage.setFilters(pageFilters);
          console.log(`Filters applied successfully to page: ${targetPage.displayName}`);
          
          return true;
        } catch (error) {
          console.error("Error applying filters:", error);
          return false;
        }
      }

      function setupLoadingTracking(report) {
        showLoading("Loading report...", "normal");
        
        report.on("loaded", async function() {
          const loadingText = document.querySelector('#loadingOverlay .loading-text');
          loadingText.textContent = 'Applying filters and rendering visuals...';
          
          try {
            // First apply report-level filters (affects all pages)
            console.log("Applying report-level filters...");
            await report.setFilters(reportFilters);
            console.log("Report-level filters applied successfully");
            
            // Get and set up pages
            await getReportPages();
            
            // Apply page-specific filters
            await applyFiltersToPage("Prospect", page1Filters);
            await applyFiltersToPage("Pinpoint", page2Filters);
            
          } catch (error) {
            console.error("Error during filter application:", error);
          }
          
          setTimeout(function() {
            showFullscreenPrompt();
          }, 1000);
        });
        
        report.on("rendered", function() {
          hideLoading();
        });
        
        report.on("pageChanged", (event) => {
          const newPage = event.detail.newPage;
          showLoading(`Loading page: ${newPage.displayName}...`, "normal");
          currentPage = pages.find(p => p.name === newPage.name) || newPage;
        });
        
        report.on("renderingStarted", function() {
          showLoading("Processing...", "normal");
        });
        
        report.on("visualRendered", function(event) {
          document.getElementById('loadingIndicator').textContent =
            `Rendered visual: ${event.detail.name}`;
        });
        
        // Modified error handler to catch token expiration errors and show the overlay
        report.on("error", function(event) {
          const errorMsg = event.detail.message.toLowerCase();
          if (errorMsg.includes("token") && errorMsg.includes("expired")) {
            showTokenExpiredOverlay();
          } else {
            showError(`Error: ${event.detail.message}`);
          }
          hideLoading();
        });
      }

      async function getReportPages() {
        try {
          pages = await report.getPages();
          currentPage = await report.getActivePage();
          const currentIndex = pages.findIndex(p => p.name === currentPage.name);
          updatePageIcon(currentIndex);
        } catch (error) {
          showError(`Error loading pages: ${error.message}`);
        }
      }
      
      function updatePageIcon(pageIndex) {
        const pageIcon = document.querySelector('.page-icon');
        const pageIconBtn = document.getElementById('pageIconBtn');
        if (!pageIcon) return;
        switch (pageIndex) {
          case 0:
            pageIcon.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24"
              fill="none" stroke="currentColor" stroke-width="2"
              stroke-linecap="round" stroke-linejoin="round">
              <circle cx="11" cy="11" r="8"></circle>
              <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
            </svg>`;
            pageIconBtn.title = "Search Page";
            break;
          case 1:
            pageIcon.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24"
              fill="none" stroke="currentColor" stroke-width="2"
              stroke-linecap="round" stroke-linejoin="round">
              <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
              <circle cx="12" cy="10" r="3"></circle>
            </svg>`;
            pageIconBtn.title = "Pin Page";
            break;
          default:
            pageIcon.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24"
              fill="none" stroke="currentColor" stroke-width="2"
              stroke-linecap="round" stroke-linejoin="round">
              <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
              <polyline points="14 2 14 8 20 8"></polyline>
              <line x1="16" y1="13" x2="8" y2="13"></line>
              <line x1="16" y1="17" x2="8" y2="17"></line>
              <polyline points="10 9 9 9 8 9"></polyline>
            </svg>`;
            pageIconBtn.title = "Page " + (pageIndex + 1);
        }
      }
      
      async function navigateToNextPage() {
        try {
          if (!pages.length || !currentPage) {
            await getReportPages();
            if (!pages.length || !currentPage) {
              throw new Error("Pages not available");
            }
          }
          const currentIndex = pages.findIndex(p => p.name === currentPage.name);
          const nextIndex = (currentIndex + 1) % pages.length;
          const nextPage = pages[nextIndex];
          showLoading(`Loading page: ${nextPage.displayName}...`, "normal");
          await nextPage.setActive();
          currentPage = nextPage;
          updatePageIcon(nextIndex);
        } catch (error) {
          showError(`Navigation error: ${error.message}`);
          hideLoading();
        }
      }
      
      if (pageIconBtn) {
        pageIconBtn.addEventListener('click', async () => {
          await navigateToNextPage();
        });
      }

      // Refresh Visuals
      const refreshBtn = document.getElementById('refreshVisualsBtn');
      if (refreshBtn) {
        refreshBtn.addEventListener('click', async () => {
          try {
            showLoading("Refreshing visuals...", "refresh");
            await report.refresh({ type: "visual" });
          } catch (error) {
            showError(`Visual refresh error: ${error.message}`);
            hideLoading();
          }
        });
      }

      // Finally embed the report
      try {
        showLoading("Loading report...", "normal");
        const reportContainer = document.getElementById('reportContainer');
        report = powerbi.embed(reportContainer, embedConfiguration);
        setupLoadingTracking(report);
        
        // Start the token refresh timer once the report is embedded
        startTokenRefreshTimer();
        
        // Clean up the token refresh timer when the window is closed or refreshed
        window.addEventListener('beforeunload', () => {
          stopTokenRefreshTimer();
        });
        
      } catch (error) {
        showError(`Initialization error: ${error.message}`);
        hideLoading();
      }
    })
    .catch(error => {
      showError("Error retrieving embed token: " + error);
      document.getElementById('loadingOverlay').style.display = 'none';
      document.getElementById('loadingIndicator').style.display = 'none';
      document.getElementById('refreshSpinner').style.display = 'none';
    });
}

  </script>
</body>
</html>
